; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "Empty"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 280
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 178
; CursorColumn    = 3
; LabelSearch     = ""
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 100
; Max GadgetList  = 100
; Max Shape       = 200
; Max Bank        = 1
; Max MenuList    = 100
; Max GTList      = 100
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 10
; Max BlitzFont   = 1
; Max Window      = 100
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
WBStartup

NoCli
; creating 4 bitmaps here for the top slice, shape-sheet and double-buffer
BitMap 0,320,44,6
BitMap 1,320,200,6
BitMap 2,320,200,6
BitMap 3,320,200,6

AMIGA

; couple types for handling state easier
NEWTYPE .vec2
  x.q
  y.q
End NEWTYPE

NEWTYPE .character
  pos.vec2
End NEWTYPE

; CONSTANTS FOR PLAYFIELD MATH
; ----------------------------

;We draw the tiles closer to one another, so the planes look better
#HALFTILE_W = 15
#HALFTILE_H = 8

#TILE_WIDTH = 30
#TILE_HEIGHT = 23
#OFFSETX = 203
#OFFSETY = 6

#TILES = 10
#XOFFSET = 295 - (#HALFTILE_W * #TILES )
#YOFFSET = 5

#CHAR_WIDTH = 26
#CHAR_HEIGHT = 17

#RENDERED_LEVEL_SHAPE = 29
#RENDERED_LEVEL_SHAPE_HIGH = 30
#CHAR_SHAPE_MIN = 31

#FONT_HEIGHT = 5
#FONT_WIDTH = 4

#TOP_BITMAP = 0
#SHAPE_SHEET_BITMAP = 3

; index of the first letter shape
#FONT_SHAPE_INDEX = 4


; we take all the shapes we need from a shape-sheet style bitmap
LoadBitMap #SHAPE_SHEET_BITMAP,"amiga:funkdungeon/vania_shapes.pic",0
Use BitMap #SHAPE_SHEET_BITMAP

;Cutting tiles here. This should be refactored in to a statement and probably rethought...
For y = 0 To 2
 GetaShape y, #OFFSETX ,#OFFSETY + (y * #TILE_HEIGHT) + y,#TILE_WIDTH,#TILE_HEIGHT
Next
; cutting "high" tiles here (doors, walls, etc.)

GetaShape 3,169,#OFFSETY, #TILE_WIDTH, #TILE_HEIGHT * 2

Gosub cutfont
GetaShape #CHAR_SHAPE_MIN, 101,79,#CHAR_WIDTH, #CHAR_HEIGHT

VWait 50

BLITZ
Buffer 0,48000
Buffer 1,48000


; the level array will hold the shape-ids to blit for each tile on the visible room
Dim level.w (#TILES,#TILES)


; we use a lookup table for isometric coordinates, as that prevents us from calculating over
; and over and over and over again (anything that gets projected as part of double-buffering is
; based on that grid, so we better keep it somewhere

Dim tileCoords.vec2 (#TILES, #TILES)

For z = 0 To #TILES - 1
  For x = 0 To #TILES  - 1
    tileCoords(x,z)\x = #XOFFSET + (#HALFTILE_W * x) - (z * #HALFTILE_W)
    tileCoords(x,z)\y = #YOFFSET + (#HALFTILE_H * x) + (z * #HALFTILE_H)
  Next
Next
; we will be double-buffering (a very oldschool way of doing it, didn't catch up with the new AB3 caps...)
; this is the bitmap to blit to
bitm = 1


Statement InitLevel{}
SHARED level(), tileCoords()
 Use BitMap  1

 For z = 0 To #TILES - 1
   For x = 0 To #TILES  - 1
   If level (z,x) < 3
     Blit level(z,x), tileCoords(x,z)\x, tileCoords(x,z)\y
   Else
     Blit 0, tileCoords(x,z)\x, tileCoords(x,z)\y
     ;Blit level(z,x), tileCoords(x,z)\x, tileCoords(x,z)\y - #TILE_HEIGHT
   EndIf

   Next
 Next
 GetaShape #RENDERED_LEVEL_SHAPE, 5,4,311,180
 Cls

; blit the ground-tiles on both double-buffer bitmaps so we can
; restore the background with BBlit/Unbuffer nicely
Use BitMap 1
 Blit #RENDERED_LEVEL_SHAPE,5,4
Use BitMap 2
 Blit #RENDERED_LEVEL_SHAPE,5,4

End Statement

Statement DrawCharacter {posx, posy, bitm}
; draws the avatar onto the playfield. This could be refactored into the DrawLevel statement
; to avoid another stack level
  SHARED tileCoords()
  BBlit bitm, #CHAR_SHAPE_MIN, tileCoords(posx,posy)\x,tileCoords(posx, posy)\y - (#CHAR_HEIGHT) / 2
End Statement

Statement DrawLevel{posx, posy, bitm}
  ; arguments: x-position and y-position of character
  ;            bitmap to draw on(
  ; drawing the level consists of
  ;  - drawing floor-tiles (immutable, pre-rendered per room in InitLevel)
  ;  - drawing high tiles (walls, doorways, ...)
  ;  - drawing character, enemies and items at the right time (ordering is important for "depth")
  SHARED level(),tileCoords()
  UnBuffer bitm

  For z = 0 To #TILES - 1
    For x = 0 To #TILES  - 1
      If z = posy AND x = posx
        DrawCharacter{posx,posy, bitm}
      EndIf
      If level (z,x) > = 3
        BBlit bitm, level(z,x), tileCoords(x,z)\x, tileCoords(x,z)\y - #TILE_HEIGHT
      EndIf
    Next
  Next
End Statement

Statement DrawText {text.s}
; we don't print text, we blit it. There is a fotn on the chaotic
; shape-sheet. Letters are cut out and then blitted based on the
; ascii-code of characters from the string.
; TODO:
;   - Add lower-case
;   - add symbols
;   - Allow for layout (multiline specifically)
 For c = 1 To Len(text)
   sindex = Asc(Mid$(text,c,1)) - 65
   If sindex > =0 AND sindex < 26
     Blit #FONT_SHAPE_INDEX + sindex,10 + c * (#FONT_WIDTH + 1),3
   EndIf
  Next
End Statement

Function.w CanMoveTo{posx, posy}
; determine whether the character can move to the coordinates passed
; we obviously can't walk over water/acid/lava or through brickwalls
  SHARED level()
  canmove.w = -1
  ; make sure to not cross the playfield
  If posx < 0 OR posx > #TILES - 1 Then canmove = 0
  If posy < 0 OR posy > #TILES - 1 Then canmove = 0

  ; make sure the target position isn't taken by something we can't pass
  If level(posy, posx) = 1 OR level(posy,posx) = 3 Then canmove = 0
  Function Return canmove
End Function

InitCopList 0,44,30,$10006,0,64,0
DisplayPalette 0,0
DisplayBitMap 0,#TOP_BITMAP

InitCopList 1,77,226 - 30 ,$10006,0,64,0
DisplayPalette 1,0
DisplayBitMap 1,1
CreateDisplay 0,1

Use BitMap #TOP_BITMAP
Cls 1
DrawText{"THIS TEXT APPEARS IN THE TOP SLICE"}

Restore leveldata
For x = 0 To #TILES - 1
 For y = 0 To #TILES - 1
  Read level(x,y)
 Next
Next

ando.character\pos\x = 1
ando.character\pos\y = 4

InitLevel{}
BlitzKeys On


; DA GAME LOOP
#KEY_UP = $4c
#KEY_DOWN = $4d
#KEY_LEFT = $4f
#KEY_RIGHT = $4e
#KEY_NONE = 0

bitm = 0
lastkey = #KEY_NONE
keyheld = False

Repeat
 If RawStatus(#KEY_RIGHT) = -1 AND lastkey <> #KEY_RIGHT
   If CanMoveTo{ando\pos\x + 1, ando\pos\y}
     ando\pos\x = ando\pos\x + 1
   EndIf
   lastkey = #KEY_RIGHT
   keyheld = True
 EndIf
 If RawStatus(#KEY_LEFT) = -1 AND lastkey <> #KEY_LEFT
   If CanMoveTo{ando\pos\x - 1, ando\pos\y}
     ando\pos\x = ando\pos\x - 1
   EndIf
   lastkey = #KEY_LEFT
   keyheld = True
 EndIf
 If RawStatus(#KEY_UP) = -1   AND lastkey <> #KEY_UP
  If CanMoveTo{ando\pos\x , ando\pos\y - 1}
    ando\pos\y = ando\pos\y - 1
  EndIf
  lastkey = #KEY_UP
  keyheld = True
 EndIf
 If RawStatus(#KEY_DOWN) = -1 AND lastkey <> #KEY_DOWN
   If CanMoveTo{ando\pos\x, ando\pos\y + 1}
     ando\pos\y = ando\pos\y + 1
   EndIf
   lastkey = #KEY_DOWN
   keyheld = True
 EndIf

 If RawStatus(#KEY_UP) = 0 AND RawStatus(#KEY_DOWN) = 0 AND RawStatus(#KEY_RIGHT) = 0 AND RawStatus(#KEY_LEFT) = 0
  lastkey = #KEY_NONE
 EndIf

 VWait
 Gosub doubleBuf
 DrawLevel{ando\pos\x,ando\pos\y, bitm}
Until Joyb(0)

End

; as long as there is a not actual core to the game, there is no point
; in designing any kind of levels. So we just read our shape-indices from this data-snippet
leveldata :
Data.w  0,0,3,0,3,0,0,0,0,0
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  0,0,2,2,2,2,2,2,0,0
Data.w  0,0,2,1,1,1,1,2,0,0
Data.w  0,0,2,1,1,1,1,2,0,3
Data.w  0,0,2,1,1,1,1,2,0,0
Data.w  0,0,2,2,2,2,2,2,0,3
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  0,0,3,0,3,0,0,0,0,0

cutfont :
 For n = 0 To 25
  GetaShape #FONT_SHAPE_INDEX + n,26 + (n * #FONT_WIDTH) + n,103, #FONT_WIDTH, #FONT_HEIGHT
 Next
Return

.doubleBuf:
 DisplayBitMap 1,bitm + 1

 bitm = 1 - bitm
 Use BitMap bitm + 1
 ;Cls
Return

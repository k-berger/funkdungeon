; XTRA
; Embedded .xtra Header
; 
; General Info
; -------------------------------------------------------
; ExePath         = "ram:"
; ExeFile         = "Empty"
; CreateIcon      = 0
; Residents       = "all.res"
; 
; Compiler
; -------------------------------------------------------
; StringBuffer    = 100000
; MakeSmallest    = 1
; FuncOptimize    = 1
; Version         = 0.0.0
; NumberOfBuilds  = 309
; 
; Debugger
; -------------------------------------------------------
; CliArgs         = ""
; StackSize       = 8192
; RuntimeDebug    = 0
; DebugInfo       = 0
; CreateDbgFile   = 0
; OverflowCheck   = 0
; AssemblerCheck  = 0
; InterruptCheck  = 1
; AutoRun         = 1
; 
; Editor
; -------------------------------------------------------
; CursorLine      = 177
; CursorColumn    = 1
; LabelSearch     = "line"
; LabelRemark     = 0
; LabelAll        = 0
; LabelPosition   = 0
; 
; Blitz Objects
; -------------------------------------------------------
; Max File        = 100
; Max GadgetList  = 100
; Max Shape       = 200
; Max Bank        = 1
; Max MenuList    = 100
; Max GTList      = 100
; Max Palette     = 4
; Max BitMap      = 10
; Max Screen      = 5
; Max IntuiFont   = 10
; Max BlitzFont   = 1
; Max Window      = 100
; Max IconInfo    = 1
; Max MUIObject   = 50
; Max AsyncReq    = 4
; Max Req-Lib     = 5
; Max GTMenuList  = 100
; Max Console     = 5
; Max TCPSock     = 5
; Max Tape        = 5
; Max Sound       = 10
; Max MedModule   = 8
; Max Buffer      = 10
; Max Queue       = 10
; Max Sprite      = 20
; Max Module      = 5
; Max Slice       = 10
; Max Page        = 4
; Max CopList     = 10
; Max PTModule    = 5
; Max Anim        = 10
; Max NChunky     = 50
; Max Chunky      = 20
; Max Stencil     = 5
; Max XBSound     = 10
; /XTRA
WBStartup

NoCli
; creating 4 bitmaps here for the top slice, shape-sheet and double-buffer
BitMap 0,320,44,6
BitMap 1,320,200,6
BitMap 2,320,200,6
BitMap 3,320,200,6
BitMap 4,320,40,6

AMIGA

; couple types for handling state easier
NEWTYPE .vec2
  x.q
  y.q
End NEWTYPE

NEWTYPE .character
  pos.vec2
End NEWTYPE

; CONSTANTS FOR PLAYFIELD MATH
; ----------------------------

;We draw the tiles closer to one another, so the planes look better
#HALFTILE_W = 15
#HALFTILE_H = 8

#TILE_WIDTH = 30
#TILE_HEIGHT = 23
#OFFSETX = 203
#OFFSETY = 6

#TILES = 10
#XOFFSET = 295 - (#HALFTILE_W * #TILES )
#YOFFSET = 5

#CHAR_WIDTH = 26
#CHAR_HEIGHT = 17


#FONT_HEIGHT = 5
#FONT_WIDTH = 4

#TOP_BITMAP = 0
#SHAPE_SHEET_BITMAP = 3

#SHAPE_COLUMN = 3
#SHAPE_WALL_H = 4

; index of the first letter shape
#FONT_SHAPE_INDEX = #SHAPE_WALL_H + 1
#RENDERED_LEVEL_SHAPE = #FONT_SHAPE_INDEX + 26
#RENDERED_LEVEL_SHAPE_HIGH = #RENDERED_LEVEL_SHAPE + 1
#INV_SHAPE_INDEX = #RENDERED_LEVEL_SHAPE_HIGH + 1
#CHAR_SHAPE_MIN = #INV_SHAPE_INDEX + 1
; we take all the shapes we need from a shape-sheet style bitmap
LoadBitMap #SHAPE_SHEET_BITMAP,"amiga:funkdungeon/vania_shapes.pic",0
Use BitMap #SHAPE_SHEET_BITMAP

;Cutting tiles here. This should be refactored in to a statement and probably rethought...
For y = 0 To 2
 GetaShape y, #OFFSETX ,#OFFSETY + (y * #TILE_HEIGHT) + y,#TILE_WIDTH,#TILE_HEIGHT
Next
; cutting "high" tiles here (doors, walls, etc.)


For h = 0 To 1
GetaShape #SHAPE_COLUMN + h,141 + (h * #TILE_WIDTH) + h,#OFFSETY, #TILE_WIDTH, #TILE_HEIGHT * 2
Next

Gosub cutfont
GetaShape #CHAR_SHAPE_MIN, 101,79,#CHAR_WIDTH, #CHAR_HEIGHT

; cutting inventory and other status shapes
GetaShape #INV_SHAPE_INDEX, 28,61,15,15

VWait 50

BLITZ
Buffer 0,48000
Buffer 1,48000


; the level array will hold the shape-ids to blit for each tile on the visible room
Dim level.w (#TILES,#TILES)


; we use a lookup table for isometric coordinates, as that prevents us from calculating over
; and over and over and over again (anything that gets projected as part of double-buffering is
; based on that grid, so we better keep it somewhere

Dim tileCoords.vec2 (#TILES, #TILES)

For z = 0 To #TILES - 1
  For x = 0 To #TILES  - 1
    tileCoords(x,z)\x = #XOFFSET + (#HALFTILE_W * x) - (z * #HALFTILE_W)
    tileCoords(x,z)\y = #YOFFSET + (#HALFTILE_H * x) + (z * #HALFTILE_H)
  Next
Next
; we will be double-buffering (a very oldschool way of doing it, didn't catch up with the new AB3 caps...)
; this is the bitmap to blit to
bitm = 1


Statement InitLevel{}
SHARED level(), tileCoords()
 Use BitMap  1

 For x = 0 To #TILES - 1
   For z = 0 To #TILES  - 1
   If level (z,x) < 3
     Blit level(z,x), tileCoords(x,z)\x, tileCoords(x,z)\y
   Else
     Blit 0, tileCoords(x,z)\x, tileCoords(x,z)\y
     ;Blit level(z,x), tileCoords(x,z)\x, tileCoords(x,z)\y - #TILE_HEIGHT
   EndIf

   Next
 Next
 GetaShape #RENDERED_LEVEL_SHAPE, 0,0,320,192
 Cls

; blit the ground-tiles on both double-buffer bitmaps so we can
; restore the background with BBlit/Unbuffer nicely
Use BitMap 1
 Blit #RENDERED_LEVEL_SHAPE,0,0
Use BitMap 2
 Blit #RENDERED_LEVEL_SHAPE,0,0

End Statement

Statement DrawCharacter {posx, posy, bitm}
; draws the avatar onto the playfield. This could be refactored into the DrawLevel statement
; to avoid another stack level
  SHARED tileCoords()
  BBlit bitm, #CHAR_SHAPE_MIN, tileCoords(posx,posy)\x,tileCoords(posx, posy)\y - (#CHAR_HEIGHT) / 2
End Statement

Statement DrawLevel{posx, posy, bitm}
  ; arguments: x-position and y-position of character
  ;            bitmap to draw on(
  ; drawing the level consists of
  ;  - drawing floor-tiles (immutable, pre-rendered per room in InitLevel)
  ;  - drawing high tiles (walls, doorways, ...)
  ;  - drawing character, enemies and items at the right time (ordering is important for "depth")
  SHARED level(),tileCoords()
  UnBuffer bitm

  For x = 0 To #TILES - 1
    For z = 0 To #TILES  - 1
      If z = posx AND x = posy
        DrawCharacter{posx,posy, bitm}
      EndIf
      If level (z,x) > = 3
        BBlit bitm, level(z,x), tileCoords(z,x)\x , tileCoords(z,x)\y - 2 - #TILE_HEIGHT
      EndIf
    Next
  Next
End Statement

Statement DrawText {row.w, text.s}
; we don't print text, we blit it. There is a fotn on the chaotic
; shape-sheet. Letters are cut out and then blitted based on the
; ascii-code of characters from the string.
; TODO:
;   - Add lower-case
;   - add symbols
;   - Allow for layout (multiline specifically)
startx.w = 160 - Len(text) * ((#FONT_WIDTH + 1) / 2)
 For c = 1 To Len(text)
   sindex = Asc(Mid$(text,c,1)) - 65
   If sindex > =0 AND sindex < 26
     Blit #FONT_SHAPE_INDEX + sindex,startx + c * (#FONT_WIDTH + 1),3 + row * (#FONT_HEIGHT + 1)
   EndIf
  Next
End Statement

Function.w CanMoveTo{posx, posy}
; determine whether the character can move to the coordinates passed
; we obviously can't walk over water/acid/lava or through brickwalls
  SHARED level()
  canmove.w = -1
  ; make sure to not cross the playfield
  If posx < 0 OR posx > #TILES - 1 Then canmove = 0
  If posy < 0 OR posy > #TILES - 1 Then canmove = 0

  ; make sure the target position isn't taken by something we can't pass
  If level(posx, posy) = 1 OR level(posx,posy) = 3 OR level(posx,posy) = 4 Then canmove = 0
  Function Return canmove
End Function

InitCopList 0,44,30,$10006,0,64,0
DisplayPalette 0,0
DisplayBitMap 0,#TOP_BITMAP

InitCopList 1,77,236 - 30 - 33 ,$10006,0,64,0
DisplayPalette 1,0
DisplayBitMap 1,1

InitCopList 2, 254, 30 ,$10006,0,64,0
DisplayPalette 2,0
DisplayBitMap 2,4

CreateDisplay 0,1,2

Use BitMap #TOP_BITMAP
For i = 0 To 4
  Blit #INV_SHAPE_INDEX, 5 + (16 * i),5
Next
Use BitMap 4
DrawText{1, "THIS TEXT APPEARS IN THE TOP SLICE"}
DrawText{2, "CENTERED AND MULTILINED"}
Restore leveldata
For z = 0 To #TILES - 1
 For x = 0 To #TILES - 1
  Read level(x,z)
 Next
Next

ando.character\pos\x = 1
ando.character\pos\y = 4

InitLevel{}
BlitzKeys On


; DA GAME LOOP
#KEY_UP = $4c
#KEY_DOWN = $4d
#KEY_LEFT = $4f
#KEY_RIGHT = $4e
#KEY_NONE = 0

bitm = 0
lastkey = #KEY_NONE
keyheld = False

Repeat
 If RawStatus(#KEY_RIGHT) = -1 AND lastkey <> #KEY_RIGHT
   If CanMoveTo{ando\pos\x + 1, ando\pos\y}
     ando\pos\x = ando\pos\x + 1
   EndIf
   lastkey = #KEY_RIGHT
   keyheld = True
 EndIf
 If RawStatus(#KEY_LEFT) = -1 AND lastkey <> #KEY_LEFT
   If CanMoveTo{ando\pos\x - 1, ando\pos\y}
     ando\pos\x = ando\pos\x - 1
   EndIf
   lastkey = #KEY_LEFT
   keyheld = True
 EndIf
 If RawStatus(#KEY_UP) = -1   AND lastkey <> #KEY_UP
  If CanMoveTo{ando\pos\x , ando\pos\y - 1}
    ando\pos\y = ando\pos\y - 1
  EndIf
  lastkey = #KEY_UP
  keyheld = True
 EndIf
 If RawStatus(#KEY_DOWN) = -1 AND lastkey <> #KEY_DOWN
   If CanMoveTo{ando\pos\x, ando\pos\y + 1}
     ando\pos\y = ando\pos\y + 1
   EndIf
   lastkey = #KEY_DOWN
   keyheld = True
 EndIf

 If RawStatus(#KEY_UP) = 0 AND RawStatus(#KEY_DOWN) = 0 AND RawStatus(#KEY_RIGHT) = 0 AND RawStatus(#KEY_LEFT) = 0
  lastkey = #KEY_NONE
 EndIf

 VWait
 Gosub doubleBuf
 DrawLevel{ando\pos\x,ando\pos\y, bitm}
Until Joyb(0)

End

; as long as there is a not actual core to the game, there is no point
; in designing any kind of levels. So we just read our shape-indices from this data-snippet
leveldata :
Data.w  0,0,3,0,0,0,0,0,0,0
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  4,0,2,2,2,2,2,2,0,0
Data.w  4,0,2,1,1,1,1,2,0,0
Data.w  4,0,2,1,1,1,1,2,0,3
Data.w  4,0,2,1,1,1,1,2,0,0
Data.w  0,0,2,2,2,2,2,2,0,0
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  0,0,0,0,0,0,0,0,0,0
Data.w  0,3,0,0,0,0,0,0,0,0

cutfont :
 For n = 0 To 25
  GetaShape #FONT_SHAPE_INDEX + n,26 + (n * #FONT_WIDTH) + n,103, #FONT_WIDTH, #FONT_HEIGHT
 Next
Return

.doubleBuf:
 DisplayBitMap 1,bitm + 1

 bitm = 1 - bitm
 Use BitMap bitm + 1
 ;Cls
Return
